# SleepBarber
Java实现多理发师理发问题，线程并发
#### 理发师问题描述：
一个理发店由一个有n个椅子的等候室和一个有一个理发椅的理发室组成。
1. 如果有没有顾客来服务，理发师就去睡觉了。
2. 如果顾客走进理发店和所有的椅子被占用了，然后顾客离开了商店。
3. 如果理发师很忙，但是椅子是可用的，那么顾客坐在一张免费的椅子上。
4. 如果理发师睡着了，顾客就会叫醒理发师。

  这是课本上的理发师问题，对于这个问题的解答网上有很多解法，可参考：[CSDN 进程(线程)间同步互斥问题
(三) 熟睡的理发师问题](https://blog.csdn.net/qq_24451605/article/details/49658607)
---

#### 加强版的问题描述：
一个理发店由一个有n个椅子的等候室和一个有m理发椅的理发室组成。
1. 如果有没有顾客可以服务，所有的理发师都去睡觉。
2. 如果顾客走进理发店椅子被占用了，然后顾客离开了商店。
3. 如果所有的理发师都很忙，但是椅子是可用的，然后顾客坐在一张免费的椅子上。
4. 如果理发师睡着了，顾客就会醒过来的理发师。

### [CLICK 实验完整描述以及要求文档链接](https://pan.baidu.com/s/1Z0gUZam2qPX32ROEJ3aEbg)
---
### 问题流程分析：
##### 让我们先来看看一个理发师的场景再现：
![理发师问题流程图.png](https://upload-images.jianshu.io/upload_images/8923455-35de4129c2e6d63e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. 阳关明媚的早上，商店开门。店里面空空如也，理发师伸了个懒腰，睡回笼觉去了。
2. 一位顾客来了，发现理发师都在睡觉，走到理发师面前，拍醒了理发师。
3. 理发师醒了之后，十分抱歉，赶快给顾客理发。
4. 理发完成，理发师告诉顾客：发理好了。
5. 客户答到：好的！转身离开理发店。
6. 理发师呼叫一下一个顾客
    + 若发现理发店恢复了空空如也的状态，就继续去睡觉了
    + 若在还有顾客在椅子上等待，理发师就去唤醒椅子上睡觉的顾客。
          + 顾客随理发师坐到理发椅上，等待理发师理发完成
          + 重复步骤4
....
##### 当有多个理发师的时候会怎么样呢。言语有点难以描述了，可以看作多个单理发师的理发师店共享等待椅子队列。每个理发师，访问相同的等待椅子，但是，理发的时候互不影响。

---

### 技术需求
为了完成这个实验，我查看了《Java核心技术 卷 I》并发内容。在Java中对于多线程同步的支持有很多方案。除了简单的锁对象（Class Lock），和条件对象（Class Condition）搭配使用之外，还有Synchronization关键字用来保护一个代码片段，避免多个线程同时修改临界区内容，也可以使用阻塞队列等。我感觉锁和条件对象比较适合这一题的解答。
锁和条件对象的的使用：
```java
 private Lock lock=new ReentrantLock();
  lock.lick();//获取这个锁，如果这个锁被另外一个线程拥有则阻塞
  lock.unlock();//释放锁

  private Condition condition = lock.newCondition();
  condition.await();//阻塞当前线程
  condition.signalAll();//释放拥有因为condition.await();的线程
  condition.siginal();//在阻塞队列中随机释放一个线程
````


那么问题来了，我们需要那些锁呢？我们再看一个理发师的情况，一个理发师锁，一个用户锁，一个互斥锁就行了。
- 理发师在没有顾客的时候，调用自己的Condition.await()。
- 用户来的时候调用Barber.Condition.singalAll();并调用 自己的Condition.await()即可;
- 理发师线程释放之后进一步向前推进，直达下一次和客户沟通的时候，挂起自己，唤醒客户线程。
- 重复上述就可完成理发师线程和用户线程的沟通了。

那么多个理发师的时候，每个理发师都有自己的用户，理发师和用户之间的信息交换是1对1的，那么也就是说每个理发师都有自己的锁和条件对象，以供顾客调用。与此同时，每个顾客应该也有自己的锁和对象让理发师调用。毕竟理发师们只不过是共享了用户队列。





